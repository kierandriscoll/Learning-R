[
["index.html", "R User Notebook 1 R User Notebook", " R User Notebook Kieran Driscoll 2018-09-16 1 R User Notebook "],
["basic-concepts.html", "2 Basic Concepts 2.1 Vectors 2.2 Lists 2.3 Factors 2.4 Dataframes 2.5 Tibbles 2.6 Extracting data from Dataframes/Tibbles 2.7 Dates 2.8 Style Guide", " 2 Basic Concepts R is an object oriented language. The main data structures (which are objects) include : Vectors - These can be single values or arrays Lists - These are arrays of values, and can contain different object types. Each item in the list can be named. Factors - These are like lists but more complicated - you will normally want to convert them to regular vectors/lists. DataFrame/tibbles - 2-dimensional tables These data objects can be manipulated using functions (which are also objects). There are built in functions, but you can also create customised functions. R functions are stored in packages in your R library. Packages can be installed that give you additional functionalities (such as machine learning or graphing capabilities). 2.1 Vectors singlevar &lt;- &#39;myvalue&#39; ##OR## multivar &lt;- c(&#39;myvalue1&#39;,&#39;myvalue2&#39;,&#39;myvalue3&#39;) ## c stands for concatenate ## Each element in the vector is indexed from 1 &gt; n. You can use these index numbers to extract information from them: multivar[2] ## Will return the second item in the vector &#39;myvalue2&#39; ## ## [1] &quot;myvalue2&quot; 2.2 Lists mylist &lt;- list(&#39;myvalue&#39;,c(123,456),list(9,99,999)) ##You can also &#39;name&#39; each item in the list ## mylist &lt;- list(&#39;a&#39;=&#39;myvalue&#39;,&#39;b&#39;=c(123,456),&#39;c&#39;=list(9,99,999)) ## R lists are a bit like dictionaries/objects## You can access Lists in the same way as vectors, however the the results will also be in a list structure. To prevent this you need to use double brackets: mylist[[1]] ## Will return the first item in the list &#39;myvalue&#39; ## ## [1] &quot;myvalue&quot; If the items in a list have been named: mylist[[&#39;a&#39;]] ## Will produce same result ## [1] &quot;myvalue&quot; 2.3 Factors If you have a Factor you can convert it to a vector list: # If your factor contains strings myfactor &lt;- factor(c(&quot;North&quot;, &quot;South&quot;, &quot;West&quot;, &quot;West&quot;, &quot;South&quot;)) as.vector(myfactor) ## [1] &quot;North&quot; &quot;South&quot; &quot;West&quot; &quot;West&quot; &quot;South&quot; # If your factor only contains numbers myfactor &lt;- factor(c(100, 200, 300, 300, 200)) as.numeric(as.vector(myfactor)) # Nb. numbers are initally held as strings, so you need to convert to numeric ## [1] 100 200 300 300 200 2.4 Dataframes # Manually create a simple dataframe with 3 columns and 2 obs peopledf &lt;- data.frame(&#39;Name&#39;=c(&#39;John Doe&#39;,&#39;John Doe&#39;,&#39;Peter Gynn&#39;,&#39;Jolie Hope&#39;), &#39;Age&#39;=c(25,29,34,38), &#39;Gender&#39;=c(&#39;M&#39;,&#39;M&#39;,&#39;M&#39;,&#39;F&#39;) ) # Alternatively you can create separate vectors first, and then use the names of the vectors instead. 2.5 Tibbles Tibbles are dataframes that can be easier to use, but you will need to load the tibble package and other tidyverse packages to work with them. library(tibble) ## Warning: package &#39;tibble&#39; was built under R version 3.4.4 # A simple tibble dataframe with 3 columns and 2 obs peopletdf &lt;- tibble::tibble( &#39;Name&#39;=c(&#39;John Doe&#39;,&#39;John Doe&#39;,&#39;Peter Gynn&#39;,&#39;Jolie Hope&#39;), &#39;Age&#39;=c(25,29,34,38), &#39;Gender&#39;=c(&#39;M&#39;,&#39;M&#39;,&#39;M&#39;,&#39;F&#39;) ) # Alternatively you can create separate vectors first, and then use the names of the vectors instead. 2.6 Extracting data from Dataframes/Tibbles Rows and columns can be extracted from dataframes and tibbes using index number or names. If you have a dataframe : ## To extract the FIRST COLUMN of values *as a DataFrame* peopledf[1] # Or peopledf[&#39;Name&#39;] ## Name ## 1 John Doe ## 2 John Doe ## 3 Peter Gynn ## 4 Jolie Hope ## To extract the FIRST ROW of values *as a DataFrame* peopledf[1,] ## Name Age Gender ## 1 John Doe 25 M ## To extract the FIRST ROW of FIRST COLUMN of values *as a Factor* peopledf[1,1] ## [1] John Doe ## Levels: John Doe Jolie Hope Peter Gynn ## If you need more than 1 row/column you can use a semi-colon (:). For example peopledf[1:3,] will return the first 3 rows. If you are using a tibble the results will be the same, but the output will always be another tibble. You can convert a tibble column into a vector/list by adding extra []. This can also be done using the pull() function from dplyr. ## Extract the first COLUMN of values *as a charater vector* peopletdf[[1]] ## [1] &quot;John Doe&quot; &quot;John Doe&quot; &quot;Peter Gynn&quot; &quot;Jolie Hope&quot; ## Extract the first ROW of first column of values *as a vector* peopletdf[[1,1]] ## [1] &quot;John Doe&quot; 2.7 Dates Dates are regarded as the number of days since 1st Jan 1970. To store a date you can use the as.Date() function which accepts dates written in the format ‘YYYY-MM-DD’. Other formats can be used is specified. datevar &lt;- as.Date(&#39;2017-04-06&#39;) 2.8 Style Guide Make sure you use correct upper/lower case spelling The three main data types are numeric, character and factor Use the setwd(‘C:/…’) function to indicate the working directory for your files Filepath reference must have forward slashes …/…/…/ Use == when evaluating equilavence, eg. if (a==b) … To time a code add the following before and after : ptm &lt;- proc.time() proc.time() - ptm To add comments: ## Comment ## "],
["importing-exporting.html", "3 Importing &amp; Exporting 3.1 Importing 3.2 Exporting", " 3 Importing &amp; Exporting There are various ways to import and export files, but the tidyverse includes the readr package. This imports data as tibbles. readxl can be used to import Excel files, and haven can import SAS/SPSS files. You can check whether a object is a tibble dataframe using the function is.tibble() Nb. Columns containing characters are automatically given the character data type. 3.1 Importing 3.1.1 Importing a CSV library(readr) datasetname &lt;- readr::read_csv(&quot;data/testdata.csv&quot;) 3.1.2 Importing a TSV datasetname &lt;- readr::read_tsv(&quot;filepath&quot;) 3.1.3 Importing a R data file readr::read_rds(&quot;challenge.rds&quot;) 3.1.4 Importing a Excel file library(readxl) readxl::read_excel(xlsx_example) 3.1.5 Importing a SAS file library(haven) datasetname &lt;- haven::read_sas(system.file(&quot;examples&quot;, &quot;iris.sas7bdat&quot;, package = &quot;haven&quot;)) 3.1.6 Importing with Base R Base R import functions can import delimited files as dataframes. datasetname &lt;- read.table(&quot;data/testdata.csv&quot;, header=TRUE, sep=&quot;,&quot;) # sep=&quot;\\t&quot; will import tab delimited files You can check whether a object is a dataframe using the function is.data.frame() Nb. Columns containing characters are automatically given the factor data type. 3.2 Exporting 3.2.1 Write to an R dataset readr::write_rds(datasetname, &quot;datasetname.rds&quot;) 3.2.2 Write to an CSV file readr::write_csv(datasetname, &quot;datasetname.csv&quot;) ###Write to a SAS dataset haven::write_sas(datasetname, &quot;datasetname.sas7bdat&quot;) "],
["manipultaing-data.html", "4 Manipultaing data 4.1 Basic data wrangling: 4.2 Summary statistics: 4.3 Conditional statements 4.4 Appending &amp; Joins: 4.5 tidyr &amp; tidy data 4.6 tibbles", " 4 Manipultaing data Most common data manpulation can be done using the tidyverse package, which includes dplyr and tidyr. They include functions to subset and merge and pivot dataframes/tibbles. 4.1 Basic data wrangling: library(dplyr) # Keep/Drop specific columns with select() dplyr::select(mtcars, mpg) # Only keeps mpg dplyr::select(mtcars,-mpg) # Drop mpg by prefixing with a &#39;-&#39; # Keep columns that meet specific conditions select_if() dplyr::select_if(mtcars, is.numeric) # Select rows that meet specific conditions using filter() dplyr::filter(mtcars, hp &gt; 100 &amp; hp &lt; 200) # Rename columns using rename() dplyr::rename(mtcars, HorsePower = hp) #Nb. the new name is specifed first New=Old # Create new columns using mutate() or transmute() dplyr::mutate(mtcars, kmpg = mpg*1.609) # OR to also drop all other columns dplyr::transmute(mtcars, kmpg = mpg*1.609) # Extract a column as a vector/list dplyr::pull(peopletdf, Age) # Sort data (ascending by default) dplyr::arrange(mtcars, wt) # add desc(wt) for descending # Extract unique values dplyr::distinct(mtcars, cyl) 4.2 Summary statistics: # Create basic statistics (eg. sum, mean, median, in, max) dplyr::summarise(mtcars, mean(mpg), median(mpg), max(mpg), freq=n() ) # You can name your stat by adding eg. statname = sum(extraStat) # Group By a column - On its own this doesnt produce anything, but when combined with other functions the results will be grouped dplyr::group_by(mtcars, am) %&gt;% dplyr::summarise(mean(wt)) # To stop R grouping you need to run: dplyr::ungroup() # Frequency count of variable (+ optional sorting of results) dplyr::count(mtcars, cyl, sort = TRUE) 4.3 Conditional statements # Creates a new variable based on the value of wt. dplyr::mutate(mtcars, newvar2 = dplyr::case_when(wt &lt; 2.5 ~ &quot;low&quot;, wt &lt; 3.5 ~ &quot;medium&quot;, TRUE ~ &quot;high&quot;)) 4.4 Appending &amp; Joins: # Add/Append dataframes together - they should have same columns names/types dplyr::bind_rows(mtcars, mtcars) # Merge dataframes by common id (other joins include inner_join, right_join) dplyr::left_join(mydf1, mydf2, by = &#39;id&#39;) # Anti-Join : Only keep rows from mydf1 if they DONT match with mydf2, eg. to remove certain types of observation dplyr::anti_join(mydf1, mydf2, by = &#39;id&#39;) 4.5 tidyr &amp; tidy data tidyr includes some extra functions for converting data to/from a tidy format. Nb. tidyr includes dplyr. library(tidyr) ## Warning: package &#39;tidyr&#39; was built under R version 3.4.4 tidydf &lt;- tibble::tibble( &#39;Year&#39;=c(2016,2016,2017,2017,2018,2018), &#39;Type&#39;=c(&#39;A&#39;,&#39;B&#39;,&#39;A&#39;,&#39;C&#39;,&#39;B&#39;,&#39;C&#39;), &#39;Amount&#39;=c(111,222,333,444,555,666) ) # Pivot tidy data so that values become columns nottidy &lt;- tidyr::spread(tidydf, key=Year, value=Amount) # Pivot data into a tidy format (ie. reverse spread) tidyr::gather(nottidy, key=Age, value=Amount, -Type) ## # A tibble: 9 x 3 ## Type Age Amount ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 A 2016 111 ## 2 B 2016 222 ## 3 C 2016 NA ## 4 A 2017 333 ## 5 B 2017 NA ## 6 C 2017 444 ## 7 A 2018 NA ## 8 B 2018 555 ## 9 C 2018 666 4.6 tibbles The tibble package includes some extra functions for altering tibbles. library(tibble) # Add new column to a tibble (with value) tibble::add_column(mydf, newcol=&#39;2014-15&#39;) "],
["functions.html", "5 Functions 5.1 Function Basics - an example using str() 5.2 Common (base) functions 5.3 Stringr - more string functions 5.4 Lubridate - more date functions 5.5 Converting data to other formats 5.6 User Defined Functions 5.7 Chaining/Piping", " 5 Functions 5.1 Function Basics - an example using str() Functions are the main way that you will handle or manipulate data. Something is a function if it is in the form functionname(arg1, arg2, …) str(datasetname) #Displays basic info about the data (like Proc Contents) To see what a function does, and what arguments it requires, you can enter the function name into the help function, eg help(str) 5.2 Common (base) functions 5.2.1 Strings # Substring - Use with any vector or list. You should include the start and end position. x &lt;- &quot;ABCDE&quot; substr(x, 3, 4) # Eg. &#39;ABCDE&#39; will become &#39;CD&#39; ## [1] &quot;CD&quot; # Search for a string within a string - will return either TRUE or FALSE. grepl(&quot;cat&quot;,&quot;the cat sat on the mat&quot;) ## [1] TRUE # Find and replace a string within a string. gsub(&quot;cat&quot;,&quot;dog&quot;, &quot;the cat sat on the mat&quot;) ## [1] &quot;the dog sat on the mat&quot; # Paste - Concatenates vectors or lists (including an optional separator). All values will be converted into strings. paste(&quot;value1&quot;, &quot;value2&quot;, sep=&quot; &quot;) ## [1] &quot;value1 value2&quot; paste0(&quot;value1&quot;, &quot;value2&quot;) # This function doesnt have any separator ## [1] &quot;value1value2&quot; # Remove leading/trailing whitespace from character strings with trimws() trimws(&quot; Hello World &quot;) ## [1] &quot;Hello World&quot; # Apply a special format to a number/string and return it as a string sprintf(&#39;%03d&#39;, 1) ## [1] &quot;001&quot; #This simple example converts 1 into a string and pads it with 0&#39;s so that it 3 characters long. The first argument defines what and how text willl be displayed. The % symbol is a placeholders that can have different types. All subsequent arguments represent the data variables that are represented by the placeholders (in the order they occur).For more info see https://www.rdocumentation.org/packages/base/versions/3.4.3/topics/sprintf. 5.2.2 Mathematical #Round/Floor/Ceiling round(5.15, digits=1) # Specify number of decimal places to round to round(515, digits=-1) # A negative digit rounds to the nearest 10^n (ie. 10, 100, 1000) floor(5.15) # Rounds down to nearest whole number ceiling(5.15) # Rounds up to nearest whole number #Sum - Only works with numeric vectors of dataframe columns sum(c(1,2,3)) sum(1,2,4) sum(mydf$extraStat) 5.2.3 Properties &amp; Lookups #Length - The number of elemnts in an object length(&quot;ABCDE&quot;) # A single vector has length 1 length(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)) # This concatenated vector has length 3 length(mydf) # The length of a Dataframe is equal to the number of columns # Identifying missing values - these are represented by the symbol NA is.na(c(1,NA,3)) # This logical function will be TRUE if a value is missing/NA # Identifying numeric vectors/columns is.numeric(c(1,&quot;A&quot;)) # This logical function will be TRUE if all values are numeric # Identifying the POSITION of the min/max value which.min(c(243,NA,55,664)) which.max(c(243,NA,55,664)) 5.2.4 Transformation #Create new columns in a dataframe (alt. dplyr has add_column) transform(mydf, ColPct=(mydf$Amount + 50) ) # Reverse elements in a vector rev(c(1,2,3,4,5)) # Format numbers to include comma separators format(mydf,big.mark=&quot;,&quot;,big.interval=3L,trim=TRUE) When a DataFrame/tibble has been created, various functions can be used to describe it, such as: dim() # Shows number of rows and colums length() # Number of columns colnames() # The colum names head() # Displays first 6 rows str() # variable name, type and example values There are also some mathematical functions, including: * summary() # Summary statistics for numeric columns (mean, min, max, Q1, Q3) * colSums() # Sum of each column * colMeans() # Mean of each column 5.3 Stringr - more string functions Loading packages will give you access to more complex functions: library(stringr) ## Warning: package &#39;stringr&#39; was built under R version 3.4.4 # Split a string into N pieces given a custom sepearator stringr::str_split_fixed(&quot;string to split&quot;, &quot;to&quot;, 2) # returns 2 strings &quot;string&quot; and &quot;split&quot; ## [,1] [,2] ## [1,] &quot;string &quot; &quot; split&quot; 5.4 Lubridate - more date functions There are various packages, such as lubridate, available that help parse and convert dates. library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following object is masked from &#39;package:base&#39;: ## ## date #This package lets you easily calculate components from a date lubridate::day(&quot;2017-04-06&quot;) ## [1] 6 lubridate::week(&quot;2017-04-06&quot;) ## [1] 14 lubridate::month(&quot;2017-04-06&quot;, label=TRUE, abbr=FALSE) # The label option switches between numeric and character month. The abbr option switches between full and abbreviated names. ## [1] April ## 12 Levels: January &lt; February &lt; March &lt; April &lt; May &lt; June &lt; ... &lt; December lubridate::quarter(&quot;2017-04-06&quot;) ## [1] 2 lubridate::year(&quot;2017-04-06&quot;) ## [1] 2017 5.5 Converting data to other formats 5.5.1 JSON library(RJSONIO) RJSONIO::toJSON(mydf) # A Dataframe will become a JSON object {&quot;&quot;:[],&quot;&quot;:[]} RJSONIO::toJSON(multivar) # A vector/list will become a JSON array [&quot;&quot;,&quot;&quot;,&quot;&quot;] 5.6 User Defined Functions The basic syntax to create a UDF is: myfunction &lt;- function(arg1, arg2, ... ){ statements return(object) } #For example this function checks whether a number is equal to 1 and returns a Yes/No vector: checkifone &lt;- function(x){ if (x==1) { return(&quot;Yes&quot;) } else return(&quot;No&quot;) } #You can return any object, including vectors, list, other objects or functions. To use a function : checkifone(23) # Or save the result of the function in a new variable functionresult &lt;- checkifone(23) #functionresult will contain either Yes or NO ## 5.7 Chaining/Piping There is an alternative way of writing R code that may be easier to read/understand. It is called chaining/piping, and it reduces the need for nested functions by using a special operator %&gt;%. #Normal R code xvar &lt;- c(1,1,2,3,5,8,13,21) #initialses an array xresult &lt;- round(log(xvar),1) # Calculates the log, and rounds to nearest dp #Chaining/Piping xvar &lt;- c(1,1,2,3,5,8,13,21) xresult &lt;- xvar %&gt;% log() %&gt;% round(1) # The %&gt;% effectively passes xvar to the log() function and the result is passed to round(). This means that complex code with multiple functions should be easier to read "],
["loops.html", "6 Loops 6.1 Basic Loop structure: 6.2 Looping with vectors 6.3 Creating a List in a Loop", " 6 Loops 6.1 Basic Loop structure: for (x in 1:5) { print(x) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 6.2 Looping with vectors loopvector &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;) for (x in 1:length(loopvector)) { print(loopvector[x]) } ## [1] &quot;a&quot; ## [1] &quot;b&quot; ## [1] &quot;c&quot; ## [1] &quot;d&quot; 6.3 Creating a List in a Loop newList &lt;- list() # An empty List for (x in 1:5) { newList[[x]] = x^2 # Inserts an element into the List } newList[[3]] ## [1] 9 "],
["html-tables.html", "7 HTML tables 7.1 Static HTML table - htmlTable 7.2 Intearctive HTML table - DT", " 7 HTML tables 7.1 Static HTML table - htmlTable htmlTable is a package that will produce the HTML code needed to display a table in a browser. library(htmlTable) htmlTable::htmlTable(cars) # You can only see what the table looks like when Knitr generates a document #There are various options to change how the table will look: #To change the column headings you need to specify every column htmlTable::htmlTable(mydf, header=c(&quot;var1&quot;,&quot;var2&quot;)) #To add a Title htmlTable::htmlTable(mydf, caption=&quot;My Table&quot;) #To align columns &#39;r&#39;=right, &#39;l&#39;=left, c=&#39;centre(default) htmlTable::htmlTable(mydf, align=&#39;r&#39;) #To add CSS formats to the table htmlTable::htmlTable(mydf, css.table = &quot;width: 100%; table-layout: fixed; word-wrap: break-word;&quot;) 7.2 Intearctive HTML table - DT DT is a package that will produce an intearctive table in a browser. library(DT) DT::datatable(regOrder) # You can only see what the table looks like when Knitr generates a document #There are various options to change how the table will look: #To remove row numbers regOrder %&gt;% DT::datatable(rownames = FALSE) #To rename columns labels regOrder %&gt;% DT::datatable(colnames = c(&quot;Region Code&quot;,&quot;Region Name&quot;,&quot;Order&quot;)) "],
["charts.html", "8 Charts", " 8 Charts There are various ways to create charts, static or interactive, in R. 8.0.1 Static charts with ggplot2 For static charts you can use the ggplot2 package. Your data must be in dataframe format. For full reference see: http://ggplot2.tidyverse.org/reference/index.html library(ggplot2) ggplot2::ggplot(mydf, aes(x = lad16cd, y = extraStat)) + geom_bar(stat=&quot;identity&quot;) # The 1st argument in ggplot() should be the name of your dataframe; # The 2nd argument should be an aesthetic attribute - this defines which variables will be on the x and y axes. # You can now add &#39;Layers&#39; to the ggplot object using the + symbol. You must have at least one &#39;geom&#39; layer that specifies what type of chart it is (eg. geom_bar, geom_point, geom_line etc..) #You can have multiple layers, for example bars and points ggplot2::ggplot(mydf, aes(x = lad16cd, y = extraStat)) + geom_bar(stat=&quot;identity&quot;) + geom_point() #There are various option for changing the colour and width [0-1] of the bars ggplot2::ggplot(mydf, aes(x = lad16cd, y = extraStat)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;orange&quot;, colour=&quot;blue&quot;, width=0.8) # To flip a bar chart from vertical to horizontal use &#39;coord_flip&#39; ggplot2::ggplot(mydf, aes(x = lad16cd, y = extraStat)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;orange&quot;, colour=&quot;blue&quot;) + coord_flip() # By default the axes labels are based on your datafram. To change these or add a title use a &#39;labs&#39; layer: ggplot2::ggplot(mydf, aes(x = lad16cd, y = extraStat)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;orange&quot;, colour=&quot;blue&quot;) + labs(y = &quot;Custom y name&quot;, x = &#39;Custome x name&#39;) + labs(title = &quot;Custom Chart Title&quot;) # The x and y axes may not always start from 0. To force this use a &#39;expand_limits&#39;: ggplot2::ggplot(mydf, aes(x = lad16cd, y = extraStat)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;orange&quot;, colour=&quot;blue&quot;) + labs(y = &quot;Custom y name&quot;, x = &#39;Custome x name&#39;) + labs(title = &quot;Custome Chart Title&quot;) + expand_limits(y = 0) # The y axis goes below 0 by default. To fix this use &#39;scale_y_continuous&#39;: ggplot2::ggplot(mydf, aes(x = lad16cd, y = extraStat)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;orange&quot;, colour=&quot;blue&quot;) + labs(y = &quot;Custom y name&quot;, x = &#39;Custome x name&#39;) + labs(title = &quot;Custome Chart Title&quot;) + expand_limits(y = 0) + scale_y_continuous(expand=c(0,0)) # You can change the appearance of most elements of the chart use a &#39;theme&#39; layer, including: # * Change the appeareance of axes (axis.line) # * Change the plot area (panel.background) # * Add/Remove/Change the gridlines (panel.grid.major.x &amp; panel.grid.major.y) # * Change the position and size of the title (plot.title) ggplot2::ggplot(mydf, aes(x = lad16cd, y = extraStat)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;orange&quot;, colour=&quot;blue&quot;) + labs(y = &quot;Custom y name&quot;, x = &#39;Custome x name&#39;) + labs(title = &quot;Custom Chart Title&quot;) + expand_limits(y = 0) + scale_y_continuous(expand=c(0,0)) + theme( axis.line = element_line(colour = &quot;black&quot;, size = 0.75, linetype = &quot;solid&quot;) ,panel.background = element_blank() ,panel.grid.major.y = element_line(colour = &quot;black&quot;, size = 0.25, linetype = &quot;solid&quot;) ,plot.title = element_text(hjust = 0.5) ) ggplot charts are saved as PNG graphic files. By deafult they have a width=7 and height=5. You can alter this is the code chunk options: {r, echo=FALSE, fig.width=8,fig.height=4} 8.0.2 Interactive charts with ggiraph The ggiraph package extends ggplot and allows interactivity. library(ggiraph) ## Warning: package &#39;ggiraph&#39; was built under R version 3.4.4 8.0.3 Interactive charts with dygraph For interactive time series charts you can use the dygraph package which is related to the dygraph javascript library. library(dygraphs) lungDeaths &lt;- cbind(mdeaths, fdeaths) #Creates the data set for the graph dygraphs::dygraph(lungDeaths) # Displays the chart with default settings #It is possible to add a range selector under the chart dygraphs::dygraph(lungDeaths) %&gt;% dygraphs::dyRangeSelector() There are lots of options that can be changed such as axis labels, legends, and colours. #Adding a title dygraphs::dygraph(lungDeaths,main=&#39;This is the chart title&#39;) #Adding a legend dygraphs::dygraph(lungDeaths,main=&#39;This is the chart title&#39;) %&gt;% dygraphs::dyLegend(show=&#39;always&#39;,width = 500) #Adding othe options dygraphs::dygraph(lungDeaths,main=&#39;This is the chart title&#39;) %&gt;% dygraphs::dyOptions(includeZero = TRUE) "],
["maps.html", "9 Maps 9.1 Leaflet 9.2 Inserting HTML &amp; Javascript directly into R", " 9 Maps 9.1 Leaflet To create interactive maps you need the leaflet library. This provides various functions that will be transalated into Javascript. 9.1.1 Display a basic map library(leaflet) mymap &lt;- leaflet::leaflet() #This initiates a map; it is possible to change the width and height here mymap &lt;- leaflet::setView(mymap,lng=-0.12481,lat=51.50811,zoom=10) #The initial location (longitude+latitude) and zoom level can be set mymap &lt;- leaflet::addTiles(mymap) #This add tiles to the map; by default it uses OpenStreetMap mymap # this will display the map 9.1.2 Add markers, shapes and popups to a map mymap &lt;- leaflet::addMarkers(mymap, lng=-0.126965, lat=51.501555, popup=&quot;HMRC&quot;) #Use longitude and latitude to place a marker. The default blue marker is used. mymap &lt;- leaflet::addCircles(mymap, lng=-0.021002, lat=51.504475,radius=10, popup=&quot;HMRC&quot;) #Use longitude and latitude to place a circle, and radius (in metres) for its size. mymap 9.1.3 Add Boundaries To add boundaries you need geojson or topojson. This needs to be converted into a format the R understands using functions in the geojsonio library. library(geojsonio) la &lt;- geojsonio::topojson_read(&#39;~/R/Local_Auths_Dec16_Gen_Clip_GB.json&#39;) R converts this geojson into a Spatial Polygon Dataframe (SPD). This should consist of 2 main attributes: data which has descriptive information about the polygon such as a name, and polygons and contains all the coordinates for each polygon. To see what the contain you can us the following: la@data la@polygons # The @ symbol is used to access different &#39;slots&#39; in the SPD. The boundary data can now be attached to the map when it is first initialized. mymap &lt;- leaflet::leaflet(la) mymap &lt;- leaflet::setView(mymap,lng=-3.332291,lat=54.978353,zoom=5) mymap &lt;- leaflet::addPolygons(mymap, color=&#39;black&#39;,weight=1, fillColor=&#39;white&#39;,fillOpacity = 0.8) #This draws the boundary lines mymap 9.1.4 Add Interactivity Highlights can be added when you hover over an area. mymap &lt;- leaflet::addPolygons(mymap, color=&#39;black&#39;, weight=1, fillColor=&#39;white&#39;, fillOpacity = 0.8 , highlight = highlightOptions( weight = 2, color = &quot;red&quot;, bringToFront = TRUE) ) Popup info can also be added when you hover over an area. This requires using the sprintf function, which includes HTML. mylabel &lt;- sprintf(&quot;&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%s&quot;, la$lad16nm, la$lad16cd ) %&gt;% lapply(htmltools::HTML) # These can can now be assigned to the label attribute mymap &lt;- leaflet::addPolygons(mymap, color=&#39;black&#39;,weight=1, fillColor=&#39;white&#39;,fillOpacity = 0.8, highlight = highlightOptions( weight = 2, color = &quot;red&quot;, bringToFront = TRUE), label = mylabel) The code that is written in the sprintf function rquires a special format. The first argument defines what and how text willl be dispalayed. It includes placeholders (eg. %s) that can have differnet types. All subsequent arguments represent the data variables that will are represented by the placeholders (in the order they occur).For more info see https://www.rdocumentation.org/packages/base/versions/3.4.3/topics/sprintf. 9.1.5 Attach extra information to your boundary dataset You will usually want to add additional data/statistics to the boundary file, so that you can improve visualition/interactivity. You can merge a regular dataframe wih an SPD provided they have a common variable (eg. ONS Id’s). # First create a dataframe with test data mydf &lt;- data.frame(&#39;lad16cd&#39;=c(&#39;E06000001&#39;,&#39;E06000002&#39;,&#39;E06000003&#39;), &#39;extraStat&#39;=c(25000,34000,38000) ) # Merge extra data into the SPD require(sp) # Need for the following merge to work correctly la &lt;- sp::merge(la, mydf, by.x = &quot;lad16cd&quot;, by.y = &quot;lad16cd&quot;) #Check that merge has worked la@data # A new column should appear with the extra data 9.1.6 Add colour based on area data First you will need to define a colour pallete, and the range of values (bins) they will apply to. This is done using the colorBin function. pal &lt;- leaflet::colorBin(&quot;YlOrRd&quot;, bins = c(0, 24999, 34000, 38000, Inf)) # &#39;YlorRd&#39; is a particular color scale. See http://colorbrewer2.org for alternatives. You could also create a user defined list of colours using Hexadecimal eg. #fcbba1 instead. Now the colour pallete can be assigned to the fillColor attribute, allomg with the variable name that will be used . mymap &lt;- leaflet::addPolygons(mymap, color=&#39;black&#39;, weight=1, fillColor=~pal(extraStat), #Nb. the ~ indicates that the variable is contained with the la SPD fillOpacity = 0.8, highlight = highlightOptions( weight = 4, color = &quot;red&quot;, bringToFront = TRUE)) 9.2 Inserting HTML &amp; Javascript directly into R Instead of using packages to create javavscript, you can insert javascript directly into Rmarkdown, and it should be displayed correctly when it Knitr is used. &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.0.0-rc.3/dist/leaflet.css&quot; /&gt; &lt;script src=&quot;https://unpkg.com/leaflet@1.0.0-rc.3/dist/leaflet.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://stamen-maps.a.ssl.fastly.net/js/tile.stamen.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;mapid&quot;&gt;&lt;/div&gt; // Define Map area/position and any background tiles var map = new L.Map(&#39;mapid&#39;, { center: new L.LatLng(53.10, -1.26),zoom: 7 }); var layer = new L.StamenTileLayer(&quot;terrain&quot;); map.addLayer(layer); "],
["rmarkdown-knitr.html", "10 RMarkdown &amp; Knitr 10.1 Knitr 10.2 YAML 10.3 Modular coding", " 10 RMarkdown &amp; Knitr 10.1 Knitr Knitr is a feature in RStudio that will turn your R programme into a HTML (or PDF/Word) document. You need to use RMarkdown, and write your R code in ‘chunks’. You can include regular markdown text, and also html, javascript or python. Knitr will evaulate all the code and embed any tables/charts/maps into the output. 10.2 YAML At the top of all RMarkdown documents there is some YAML code: --- title: &quot;Untitled&quot; output: html_document --- YAML includes information that tells Knitr what type of document to create. In the example above it wil be a HTML document. However it cann also be used to add a table of contents, or to allow users to input cutom paraemters. Adding a table of contents --- title: &quot;Untitled&quot; output: html_document toc: TRUE --- Nb. That the contents is automatically generated based on any RMarkdown header tags ‘#’ that you have used. Adding parameters Parameters can be added after the params: option. They must have a label and a value. By defaut the parameter will be a textbox. --- title: &quot;Untitled&quot; output: html_document params: parametername1: label: &quot;Display label&quot; value: &quot;Default value&quot; --- Different types of parameter input are allowed, such as check boxes and dropdown lists. --- title: &quot;Untitled&quot; output: html_document params: mycheckboxparam: label: &quot;Display label&quot; value: TRUE mydropdownparam: label: &quot;Display label&quot; value: apples input: select choices: [apples,oranges,bananas] --- You can refer to the parameter values in the rest of the your code using the form params%parametername1 To use these parameters the Rmarkdown document must be Knitted using ‘Knit with parameters…’ 10.3 Modular coding If your R code is written in modules, then you can call them using the source() function, eg: source(&#39;module1.r&#39;) source(&#39;module2.r&#39;) "],
["machine-learning-predictive-analytics.html", "11 Machine Learning &amp; Predictive Analytics", " 11 Machine Learning &amp; Predictive Analytics 11.0.1 Decision Trees To prodcue decision tress you need to use variuos packages, such as rpart for recursive partioning and caret. ## Create a decision tree library(rpart) TreeResults &lt;- rpart::rpart(force~mass + acceleration, data=dataset1, method=&quot;class&quot;, control = rpart.control(minsplit = 30, cp = 0)) ## Visualise the decision tree rattle::fancyRpartPlot(TreeResults) ## Use model to predict value predictions &lt;- predict(TreeResults, dataset1, type = &quot;class&quot;) ## Evaluate the results confusionMatrix(predictions, dataset1$force) "],
["text-mining-nlp.html", "12 Text Mining &amp; NLP 12.1 Create a Term Document Matrix 12.2 Topic Modelling &amp; Latent Dirichlet Allocation (LDA) 12.3 Naive Bayes Classifiers 12.4 TF-IDF Classifiers (Supervised) 12.5 Sentiment Analysis 12.6 Word Bubble", " 12 Text Mining &amp; NLP There are various types of analysis you can do with text data, such as n-grams, sentiemnt analysis, and topic modelling. Various packages are available, the main ones are tm and NLP. 12.0.1 Text data The source data for your text may come in various formats, for example a single string or a dataframe. Ideally you will put these into a tidy format # Text data as a list of strings textdoc &lt;- c(&quot;Once upon a time&quot;, &quot;in a galaxy far far away&quot;, &quot;On a dark and stormy night&quot;) # Text data as a tibble/dataframe textdoc &lt;- tibble(&#39;line&#39;=c(1,2,3), &#39;text&#39;=c(&quot;Once upon a time&quot;, &quot;in a galaxy far far away.&quot;, &quot;on a dark and stormy night&quot;)) 12.0.2 Tidy text Ideally you will convert your text data into a tidy format using the tidytext package. library(tidytext) ## Warning: package &#39;tidytext&#39; was built under R version 3.4.4 textdoc %&gt;% unnest_tokens(input=text, output=word, token=&quot;words&quot;, to_lower = TRUE) -&gt; tidytext # This splits up your text into &#39;tokens&#39;. # By default a token is a word, but other options include &quot;characters&quot;, &quot;sentences&quot;,&quot;ngrams&quot;. # By default all text will be converted to lowercase, and punctuation (eg .,!?£$&amp;) will be removed. # Numbers are not removed. tidytext includes a stop_words tibble, which contain stopwords sourced from SMART, snowball, and onix. You can remove these stopwords from you tidy data by doing an anti join, or create your own custom stopword tibble. library(dplyr) ## Warning: package &#39;dplyr&#39; was built under R version 3.4.4 ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:lubridate&#39;: ## ## intersect, setdiff, union ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union stop_words ## # A tibble: 1,149 x 2 ## word lexicon ## &lt;chr&gt; &lt;chr&gt; ## 1 a SMART ## 2 a&#39;s SMART ## 3 able SMART ## 4 about SMART ## 5 above SMART ## 6 according SMART ## 7 accordingly SMART ## 8 across SMART ## 9 actually SMART ## 10 after SMART ## # ... with 1,139 more rows # Remove all common stopwords from your data tidytext %&gt;% anti_join(stop_words) -&gt; tidytext2 ## Joining, by = &quot;word&quot; # Remove stopwords from a particular source (eg. snowball) from your data tidytext %&gt;% anti_join(filter(stop_words, lexicon==&quot;snowball&quot;)) -&gt; tidytext2 ## Warning: package &#39;bindrcpp&#39; was built under R version 3.4.4 ## Joining, by = &quot;word&quot; # Custom stopwords custom_sw &lt;- tibble(word=c(&quot;a&quot;,&quot;in&quot;,&quot;on&quot;,&quot;and&quot;)) tidytext %&gt;% anti_join(custom_sw) -&gt; tidytext2 ## Joining, by = &quot;word&quot; # Nb. the tm package also includes a stopword function with the same list of words 12.0.3 Stemming library(SnowballC) tidytext2 &lt;- tidytext2 %&gt;% mutate(word_stem = wordStem(word, language=&quot;english&quot;)) 12.0.4 Basic text stats If the text data is in a tidy format you can easily to use dplyr to manipulate data, such as produce word frequency: tidytext %&gt;% count(word, sort = TRUE) # Produces token frequency using dplyr count() function ## # A tibble: 13 x 2 ## word n ## &lt;chr&gt; &lt;int&gt; ## 1 a 3 ## 2 far 2 ## 3 and 1 ## 4 away 1 ## 5 dark 1 ## 6 galaxy 1 ## 7 in 1 ## 8 night 1 ## 9 on 1 ## 10 once 1 ## 11 stormy 1 ## 12 time 1 ## 13 upon 1 12.0.5 N-Grams analysis To look at neighbouring words you need to use the unnest_token function again: textdoc %&gt;% unnest_tokens(input=text, output=ngram, token=&quot;ngrams&quot;, n=2) -&gt; ngramdoc # All text will be converted to lowercase, and punctuation (eg .,!?£$&amp;) will be removed, but numbers are not removed. #N-gram frequency ngramdoc %&gt;% count(ngram, sort = TRUE) ## # A tibble: 13 x 2 ## ngram n ## &lt;chr&gt; &lt;int&gt; ## 1 a dark 1 ## 2 a galaxy 1 ## 3 a time 1 ## 4 and stormy 1 ## 5 dark and 1 ## 6 far away 1 ## 7 far far 1 ## 8 galaxy far 1 ## 9 in a 1 ## 10 on a 1 ## 11 once upon 1 ## 12 stormy night 1 ## 13 upon a 1 12.0.6 Text Preparation with tm An alternative way of working with text data is to use the tm package. This includes text cleaning functions. This pacakge uses a data structure Corpus. library(tm) # Also loads NLP ## Warning: package &#39;tm&#39; was built under R version 3.4.4 ## Loading required package: NLP #Convert yor text data into a Corpus textdoc %&gt;% VectorSource() %&gt;% Corpus() -&gt; myCorpus # You can clean your corpus using the tm_map() function. This has various options: tm_map(myCorpus, content_transformer(tolower)) # Changes text to lowercase ## &lt;&lt;SimpleCorpus&gt;&gt; ## Metadata: corpus specific: 1, document level (indexed): 0 ## Content: documents: 2 tm_map(myCorpus, removePunctuation) # Removes all punctuations [.,&#39;:;] from your Corpus ## &lt;&lt;SimpleCorpus&gt;&gt; ## Metadata: corpus specific: 1, document level (indexed): 0 ## Content: documents: 2 tm_map(myCorpus, removeNumbers) # Removes any numbers from your Corpus ## &lt;&lt;SimpleCorpus&gt;&gt; ## Metadata: corpus specific: 1, document level (indexed): 0 ## Content: documents: 2 tm_map(myCorpus, stripWhitespace) # Removes multiple whitespace ## &lt;&lt;SimpleCorpus&gt;&gt; ## Metadata: corpus specific: 1, document level (indexed): 0 ## Content: documents: 2 tm_map(myCorpus, removeWords, c(&quot;i&quot;, &quot;a&quot;, &quot;is&quot;, &quot;the&quot;, &quot;and&quot;, &quot;but&quot;) ) # Removes custom stopwords ## &lt;&lt;SimpleCorpus&gt;&gt; ## Metadata: corpus specific: 1, document level (indexed): 0 ## Content: documents: 2 # A stopwords() function is available, and can be added to the list above, for example tm_map(myCorpus, removeWords, c(stopwords(&quot;en&quot;)) ) # Removes stopwords in the snowball list ## &lt;&lt;SimpleCorpus&gt;&gt; ## Metadata: corpus specific: 1, document level (indexed): 0 ## Content: documents: 2 12.1 Create a Term Document Matrix Transforming text data into a matrix allows you to do further modelling such as LDA, Naive Bayes, regression. ### From tidy data # First, the tidy data needs to be summarised so that it contains the count of each token per document. tidytext %&gt;% count(line, word, sort = TRUE) -&gt; tidytext_count # Now use the cast_dtm function to convert this into a Document Term Matrix. tidytext_count %&gt;% cast_dtm(line, word, n) -&gt; myDTM ## Warning: Trying to compute distinct() for variables not found in the data: ## - `row_col`, `column_col` ## This is an error, but only a warning is raised for compatibility reasons. ## The operation will return the input unchanged. inspect(myDTM) ## &lt;&lt;DocumentTermMatrix (documents: 3, terms: 13)&gt;&gt; ## Non-/sparse entries: 15/24 ## Sparsity : 62% ## Maximal term length: 6 ## Weighting : term frequency (tf) ## Sample : ## Terms ## Docs a and away dark far galaxy in once time upon ## 1 1 0 0 0 0 0 0 1 1 1 ## 2 1 0 1 0 2 1 1 0 0 0 ## 3 1 1 0 1 0 0 0 0 0 0 12.1.1 From a Corpus (by default words less than 3 characters are excluded) myDTM &lt;- DocumentTermMatrix(myCorpus) 12.2 Topic Modelling &amp; Latent Dirichlet Allocation (LDA) We can build an unsupervised LDA model using a DocumentTermMatrix library(topicmodels) # Not available # my_lda &lt;- LDA(myDTM, k=4, control = list(seed=87533)) # k is the number of topics you want. # Option 1 : using tidytext to examine topic probabilities topics_beta &lt;- tidy(my_lda, matrix=&quot;beta&quot;) # beta represents word/topic probabilities topicstats &lt;- topics_beta %&gt;% group_by(topic) %&gt;% top_n(10,beta) %&gt;% ungroup() %&gt;% arrange(topic, -beta) #Top terms for each topic topics_gamma &lt;- tidy(my_lda, matrix=&quot;gamma&quot;) # gamma represents document/topic probabilities classification &lt;- topics_gamma %&gt;% group_by(document) %&gt;% top_n(1,gamma) %&gt;% ungroup() # Most likely topic for each document # Merge back to original document classification &lt;- mutate(classification, id=as.numeric(document)) final &lt;- left_join(textdoc, classification, by=&quot;id&quot;) More complex analysis of LDA including graph topicstats %&gt;% mutate(term = reorder(term, beta)) %&gt;% ggplot(aes(term, beta, fill = factor(topic))) + # plot beta by theme geom_col(show.legend = FALSE) + # as a bar plot facet_wrap(~ topic, scales = &quot;free&quot;) + # which each topic in a seperate plot labs(x = NULL, y = &quot;Beta&quot;) + # no x label, change y label coord_flip() # turn bars sideways 12.3 Naive Bayes Classifiers library(e1071) 12.4 TF-IDF Classifiers (Supervised) 12.5 Sentiment Analysis 12.6 Word Bubble To create a word bubble visualisation we can use ggplot2 and the packcircles package, which decides the size and position of bubbles mytext &lt;- tibble(&#39;Comment&#39;=c(&#39;very good, easy to use once setup, couldnt do what i wanted, very quick way of cahnging details. it took only a few minutes to do what i needed. not all my information was correct. lots of confusing information, really good. quick and easy&#39;) ) # Use tidytext to extract all the words and remove stopwords library(tidytext) mytext %&gt;% unnest_tokens(input=Comment, output=word, token=&quot;words&quot;, to_lower = TRUE) -&gt; tidytext tidytext %&gt;% anti_join(filter(stop_words, lexicon==&quot;snowball&quot;)) -&gt; tidytext2 ## Joining, by = &quot;word&quot; # Calculate word frequency and average score tidytext3 &lt;- group_by(tidytext2, word) %&gt;% summarise(freq=n()) # The packcircles packages decides how to arrange a group a circles, automatically calculating their size and coordinates library(packcircles) ## Warning: package &#39;packcircles&#39; was built under R version 3.4.4 circles &lt;- circleProgressiveLayout(tidytext3$freq, sizetype=&#39;area&#39;) # Circle size is proportional to frequeny # Add coordinates back to list of words tidytext3 = cbind(tidytext3, circles) # Prodcue vertices so that the circles acan be constructed circles2 &lt;- circleLayoutVertices(circles, npoints=40) # Option to choose how many vertices - more means better drawn circle # Plot circles using ggplot2 &amp; ggiraph library(ggiraph) library(ggplot2) ## Warning: package &#39;ggplot2&#39; was built under R version 3.4.4 ## ## Attaching package: &#39;ggplot2&#39; ## The following object is masked from &#39;package:NLP&#39;: ## ## annotate mybc &lt;- ggplot() + geom_polygon_interactive(data = circles2, aes(x, y, group = id, data_id = id), alpha = 0.6) + scale_fill_manual(values=&quot;steelblue&quot;) + geom_text(data = tidytext3, aes(x, y, size = freq, label = word)) + scale_size_continuous(range = c(1,13)) + theme_void() + theme(legend.position=&quot;none&quot;) + coord_equal() ggiraph(ggobj = mybc, width_svg = 12, height_svg = 12) ## Warning: package &#39;gdtools&#39; was built under R version 3.4.4 "],
["shiny.html", "13 Shiny 13.1 Basic Shiny Structure 13.2 User Interface 13.3 Server", " 13 Shiny Lets you present tables and charts that will react to inputs. 13.1 Basic Shiny Structure library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Hello Shiny!&quot;) ) server &lt;- function(input, output) { } shinyApp(ui, server) 13.2 User Interface 13.2.1 Layout Various layouts can be used however the most common is a fluid layout. The page can be divided into rows and columns. Fixed text and styling can also be added. library(shiny) ui &lt;- fluidPage( fluidRow( column(width=4, &quot;row1 column1&quot;, style = &quot;background-color:red;&quot;), column(width=4, &quot;row1 column2&quot;, style = &quot;background-color:orange;&quot;), column(width=4, &quot;row1 column3&quot;, style = &quot;background-color:yellow;&quot;) ), fluidRow( column(width=4, &quot;row2 column1&quot;, style = &quot;background-color:green;&quot;), column(width=4, &quot;row2 column2&quot;, style = &quot;background-color:blue;&quot;), column(width=4, &quot;row2 column3&quot;, style = &quot;background-color:purple;&quot;) ) ) server &lt;- function(input, output) { } shinyApp(ui, server) 13.2.2 Inputs There are various Inputs that can be added to the UI. Behind the scenes these generate HTML code: * sliderInput() # Adds an input slider * fileInput() # Adds a file selector * textInput() # Adds a text input box * selectInput() # Adds a dropdown list * actionButton() # Adds an action button * dateRangeInput() # Adds a date selector The first argument of all the inputs/ouputs is a unique id. ui &lt;- fluidPage( fluidRow( column(width=4, sliderInput(&quot;slider&quot;, &quot;Generate n randoms&quot;, min = 0, max = 1000, value = 500, step = 100) ), column(width=4, fileInput(&quot;loadfile&quot;, &quot;Choose file&quot;)), column(width=4, selectInput(&quot;dropdown&quot;, &quot;Select an option&quot;, c(&quot;Rare&quot; = &quot;1&quot;, &quot;Medium&quot; = &quot;2&quot;, &quot;Well Done&quot; = &quot;3&quot;))) ) ) server &lt;- function(input, output) { } shinyApp(ui, server) 13.2.3 Outputs There are various Outputs that can be added to the UI: * htmlOutput() # Adds space for text * tableOutput() # Adds space for a table * plotOutput() # Adds space for a chart Nb. these will be empty until a function is added to the server that adds content. ui &lt;- fluidPage( fluidRow( htmlOutput(&quot;text1&quot;, width=&quot;75%&quot;, height=&quot;50px&quot;), tableOutput(&quot;table1&quot;), plotOutput(&quot;chart1&quot;, width=&quot;75%&quot;, height=&quot;100px&quot;) ) ) server &lt;- function(input, output) { } shinyApp(ui, server) Other packages extend shiny ui outputs. * plotlyOutput # Adds space for a plotly chart [plotly] * ggiraphOutput # Adds space for a ggiraph chart [ggiraph] * DTOutput # Adds space for a data table [DT] 13.3 Server UI inputs and outputs wont work unless they link to a server process/function. 13.3.1 Linking to UI outputs renderPlot() # creates reactive ggplot output renderText() # creates reactive tetx output renderTable() # creates reactive table output renderDataTable() # creates reactive DT output The UI output id and the server output name must match. ui &lt;- fluidPage( fluidRow( plotOutput(&quot;chart1&quot;) ) ) server &lt;- function(input, output) { # This output links to the ui plotOutput via the id &quot;chart1&quot; output$chart1 &lt;- renderPlot({ plot(mtcars$wt, mtcars$mpg) }) } shinyApp(ui, server) Other packages extend shiny server outputs. * renderPlotly # creates reactive plotly chart [plotly] * renderggiraph # creates reactive ggiraph chart [ggiraph] 13.3.2 Linking to UI inputs The UI input id and the server input name must match. ui &lt;- fluidPage( fluidRow( selectInput(&quot;dropdown&quot;, &quot;Select an option&quot;, c(&quot;Weight&quot; = &quot;wt&quot;, &quot;Horespower&quot; = &quot;hp&quot;, &quot;Cylinders&quot; = &quot;cyl&quot;)) ), fluidRow( plotOutput(&quot;chart1&quot;) ) ) server &lt;- function(input, output) { # This output links to the ui plotOutput via the id &quot;chart1&quot; output$chart1 &lt;- renderPlot({ plot(mtcars[[input$dropdown]], mtcars$mpg) }) } shinyApp(ui, server) "],
["shiny-dashboard.html", "14 Shiny Dashboard", " 14 Shiny Dashboard Provides a dashboard template for Shiny Apps. library(shiny) library(shinydashboard) "]
]
